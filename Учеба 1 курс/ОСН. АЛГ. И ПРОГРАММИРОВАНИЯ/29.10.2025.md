# Динамические массивы
[[ОАИП]]
это структура данных, размер которой может изменяться во время исполнения программы

	В отличии от [[22.10.2025]] статического массива, размер которого задаётся на момент компиляции, динамический позволяет регулировать объём памяти в соответствии с реальными данными.

## **Особенности массива
- Выделение вручную
- Гибкий Размер
- ручное освобождение памяти
- хранение в куче
- нет проверки границ
- имя - указатель
- инициализация


# Выделение вручную.  Malloc
malloc выделяет один блок памяти заданного размера. если выделение прошло успешно, функция возвращает указатель на начало выделенной области. Если память выделить не удалось, возвращается нулевой указатель null

## **Особенности работы
- выделенная память не инициализируется, то есть содержит случайные данные.
- указатель на выделенную память нужно сохранить - если "потерять" его, то выделенную память будет невозможно освободить.

`malloc (размер_блока_в_байтах)`
`int *arr =malloc(10 * sizeof(int)); // Массив из 10 int`

# выделение вручную. Calloc
calloc выделяет память для массива элементов. Размер выделенной памяти равено произведению количества элементов (num) на размер каждого элемента (size)

## **Особенности работы
- все биты распределённой памяти инициализируются нулями.
- функция возвращает указатель на первый байт выделенной области.
- если для удовлетворения запроса нет достаточного объема памяти, возвращается нулевой указатель.
calloc (кол-во_элементов,размер_элемента)
` int *arr = calloc(size, sizeof(int)); // Инициализация нулями`

# Гибкий размер. Realloc
**память** при использовании функции **realloc выделяется путём перераспределения ранее выделенного блока.** Функция изменяет размер блока памяти, на который указывает указатель, и возвращает указатель на перераспределённый блок.

**Содержимое блока в пределах наименьшего** из нового и старого размеров остаётся **неизменным**, хотя **новый блок может находиться в другом расположении**. Если недостаточно **свободной памяти для расширения блока до заданного размера,** возвращается **нулевой указатель, а исходный блок остаётся неизменным.**

realloc (адрес_имеющегося_блока, новый_размер)
`arr = realloc(arr, 20 * sizeof(int)); // Увеличили до 20 элементов`

# Ручное освобождение памяти. Free()
Функция free() в языке Си - это стандартная библиотечная функция, которая освобождает ранее выделенную динамическую память.

Единственный аргумент функции - указатель на блок памяти, который необходимо освободить. Если указатель равен null, то никаких действий не происходит.

free(адрес_блока)
`free(arr);`

**==Обязательно нужно освобождать через free, иначе будет утечка памяти.==

# Хранение в куче (heap)
**Куча (heap) в программировании** - это область оперативной памяти компьютера, которая используется для **динамического выделения памяти** во время выполнения программы.

## **Особенности
- **динамический размер**. Куча не ограничена заранее и может расти до доступных ресурсов системы.
- **Глобальный доступ**. К данным, хранящимся в куче, можно обращаться из любой части кода, они не привязаны к стеку вызовов.
- **Возможность многократного использования**. После освобождения память в куче можно выделять заново.


# Ошибки при работе с памятью
1. Доступ к невыделенной памяти
Проблема : использование массива или указателя без предварительного выделения памяти.
Решение: всегда проверяйте указатель на null перед обращением.
2. Повторное освобождение памяти.
Проблема: Двойной вызов free() приводит к повреждению структуры памяти.
Решение: После освобождения блока присваивайте указателю null, чтобы избежать повторного удаления
3. Утечка памяти
Проблема: Неосвобожденные блоки памяти накапливаются и снижают производительность.
Решение: Своевременно освобождайте ненужные ресурсы и используйте инструменты для детектирования утечек.

# Динамическая матрица
Особенности:
- выделение памяти происходит в процессе работы программы
- память для данных выделяется несколькими блоками
- дополнительно требуется массив указателей
- имя массива - указатель на указатель
- для обращения к элементу нужны два индекса
- выход за пределы "строки" - Ошибка

```
a = (int**)malloc(m * sizeof(int*));
for (int i = 0; i < M; i++)
a[i] = (int*)malloc (N * sizeof(int));
-- выделение памяти

Освобождение памяти
for (int i = 0; 9i < M; i++)
	free (a[i]);
free (a);
```
- - - 
```
tmp = a[k];
a[k] = a[v];
a[v] = = tmp;

```
Перестановка местами строки с индексами k и v
- - - 

```
free (a[k-1]); - удаляем строку
for ( i = k - 1; i < M - 1; i++)
	a[i] = a[i+1]; переставляем указатели
a[M-1] = NULL;
```
удалить из матрицы k-ю строку.
- - - 
