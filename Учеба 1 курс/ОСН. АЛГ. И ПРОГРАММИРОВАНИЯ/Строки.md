[[ОАИП]] 03.12.2025

# Особенности строки
- ==**имя строки - указатель на первый символ строки==
- длина как минимум на 1 меньше размера массива
- строка ограничена первым нулем, даже если в массиве их несколько 
- длину строки можно вычислить
**Си-строка** - это массив символов, где последний элемент всегда - терминальный символ `'\0'`

![[image-83.png|452x294]]
- С помощью scanf()

| спецификатор | что считывается                                        |
| ------------ | ------------------------------------------------------ |
| s            | строка до разделителя (одно слово!)                    |
| `[...]`      | строка до первого символа, не входящего в перечисление |
| `[^...]`     | строка до первого символа, входящего в перечисление    |
```
char s[80];
1) scanf ("%s, s); - "hello,"
2) scanf ("%[abcdefgh\t ]", s) - "he"
3) scanf ("%[^ ,.]", s); - "hello"
4) scanf ("%[123]", s); - ничего не считано сканф возвращает 0, значение s не изменилось
```
==**Во избежание выхода за пределы массива укажите ширину поля ввода**== 

# Ввод строки
- с помощью функции fgets ()
## Особенности 
- второй параметр задает размер массива size, считано будет не более size-1 символа
- если длина входной строки меньше size-1 строка считывается по символ перехода на новою строку
- символ перехода на новую строку остается в строке, следом записывается '\0'
- в случае ошибки возвращает null
Вызов
```
char str[80];
fgets (str, 80, stdin);
```

# Обработка строк
putc;puts
## Особенности
- обработка осуществляется в цикле
- если строка обрабатывается целиком, то обработка осуществляется до нуль-терминатора
![[image-92.png|509x377]]
![[image-93.png|510x377]]
![[image-94.png|513x441]]
==**При копировании и сцеплении строк важно следить за длиной строки и помнить, что обработка идет в цикле!**==
# Поиск в строке

==**Все функции поиска возвращают адрес найденного символа или подстроки или NULL, если образец не найден**==

поиск символа
`char * strchr (const char *, char);` const char (где искат) char (что искать)
последнее вхождение
`char * strchr (const char *, char);`
Поиск **любого символа из подмножества**
`char * strpbrk (const char *, const char(подмножество) *);`
Поиск подстроки
`char * strstr (const char *, const char *);`
	`Где искать *, что искать`
Выделение лексем
`char * strtok (char *, const char *);`
	Где искать: при первом вызове - адрес начала строки, при последующих - NULL `*,` Множество разделителей

![[image-95.png|468x334]]

![[image-96.png|516x273]]
![[image-97.png|515x322]]