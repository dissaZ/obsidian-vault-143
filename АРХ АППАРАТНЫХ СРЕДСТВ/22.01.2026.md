[АРХ. АППАРАТНЫХ СРЕДСТВ]
1. Машина фон Неймана — абстрактная модель ЭВМ. • Машина Тьюринга может обрабатывать входные слова любой длины, поэтому ее принципиально нельзя реализовать; • Машина фон Неймана не поддается реализации по другой причине: многие детали в архитектуре этого вычислителя не конкретизированы. Она описана не на внутреннем, а только на концептуальном уровне видения архитектуры.
2. Память машины фон Неймана — это линейная (упорядоченная) и однородная последовательность некоторых элементов, называемых ячейками (memory sells). В любую ячейку памяти другие устройства машины могут записывать и считывать информацию, причем время чтения из любой ячейки одинаково для всех ячеек памяти. Время записи в любую ячейку тоже одинаково (это и есть принцип однородности памяти).
3. **Ячейка** — это «коробочка» в памяти, где хранится кусочек данных.
- **Адрес** — это уникальный номер этой «коробочки», чтобы процессор мог её найти.
- **Машинное слово** — это максимальное количество данных, которое процессор может обработать за один раз.

# Самостоятельная работа дв код

1. **1984:** 11111000000
- **4000:** 111110100000
- **8192:** 10000000000000 (это 2^13)
2. 
**Десятичная:** Каждая цифра справа налево — это степень двойки (1, 2, 4, 8, 16...). Мы просто складываем те значения, где стоят единицы.

**Восьмеричная:** Каждые 3 двоичные цифры — это одна восьмеричная (от 0 до 7). Группируем с правого конца.

**Шестнадцатеричная:** Каждые 4 двоичные цифры — это одна шестнадцатеричная цифра (от 0 до F). Это самый компактный вид записи кода.

3. 
*   **В десятичную:** $512 + 64 + 32 + 8 + 1$ = **617**
*   **В восьмеричную:** = **1151₈**
*   **В шестнадцатеричную:**  = **269₁₆**

3. 
  `00101101 + 01101111` = **10011100** 
  `11111111 + 11111111` = **11111110** 
  `00000000 − 11111111` = **00000001** 
  `11110111 − 11110111` = **00000000** 
4. 
`00101101 + 01101111` = **10011100** 

`11111111 + 11111111` = **11111111** 

5.  
**Знаковый бит:** Это просто самая левая цифра результата.
*   **Переполнение (Overflow):** Оно происходит, когда мы складываем два числа одного знака, а получаем результат другого знака.
    *   *Пример:* `100 (-4) + 100 (-4)`. Мы ждем `-8`, но в 3 бита влезает максимум `-4`. Результат "зацикливается" и превращается в `0`. Это и есть ошибка переполнения.


6. 
Умножаем `0111` (7) на `0011` (3):


    0111
  x 0011
  ------
    0111
 + 01110
  10101 (в десятичной системе это 21)
